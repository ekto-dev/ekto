// Code generated by protoc-gen-ekto. DO NOT EDIT.
// source: proto/example_service.proto
package example

import (
	"context"
	"net"
	"net/http"

	ektoserver "github.com/ekto-dev/ekto/server"
	"github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
	"golang.org/x/sync/errgroup"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
	"google.golang.org/grpc/reflection"
	"google.golang.org/protobuf/encoding/protojson"
)

func StartNotificationServiceServer(ctx context.Context, rpcListenAddr string, srv NotificationServiceServer, opts ...ektoserver.Option) error {
	server := grpc.NewServer()
	RegisterNotificationServiceServer(server, srv)
	reflection.Register(server)

	eg, _ := errgroup.WithContext(ctx)
	eg.Go(func() error {
		lis, err := net.Listen("tcp", rpcListenAddr)

		if err != nil {
			return err
		}

		return server.Serve(lis)
	})
	ektoServer := ektoserver.NewEktoServer(opts...)
	if ektoServer.HasGateway() {
		eg.Go(func() error {
			conn, err := grpc.DialContext(
				ctx,
				rpcListenAddr,
				grpc.WithBlock(),
				grpc.WithTransportCredentials(insecure.NewCredentials()),
			)

			if err != nil {
				return err
			}

			gwmux := runtime.NewServeMux(
				runtime.WithMarshalerOption(
					runtime.MIMEWildcard,
					&runtime.JSONPb{
						MarshalOptions: protojson.MarshalOptions{
							UseProtoNames: true,
						},
					},
				),
			)

			err = RegisterNotificationServiceHandler(ctx, gwmux, conn)
			if err != nil {
				return err
			}

			gwServer := &http.Server{
				Addr:    ektoServer.GatewayAddr(),
				Handler: gwmux,
			}

			return gwServer.ListenAndServe()
		})
	}

	return eg.Wait()
}
